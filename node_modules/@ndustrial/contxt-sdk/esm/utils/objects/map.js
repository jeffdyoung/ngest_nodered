var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

import isPlainObject from 'lodash.isplainobject';

/*
 * Maps over an object (which can include nested objects and arrays).
 *
 * @param {Object} input The object to map over
 * @param {Function} callback The function invoked per iteration
 * @param {Object} [userOptions]
 * @param {Boolean} [userOptions.deep = false] Boolean indicating if only the first
 *   level should be mapped or if it should recursively map over nested
 *   objects/arrays
 *
 * @returns {Object}
 *
 * @private
 */
function map(input, callback, userOptions) {
  var options = _extends({
    deep: false
  }, userOptions);

  return Object.keys(input).reduce(function (memo, key) {
    var value = input[key];
    var result = callback(value, key, input);

    var _result = _slicedToArray(result, 2),
        newValue = _result[0],
        newKey = _result[1];

    if (newKey === '__MARKED_FOR_REMOVAL__') {
      return memo;
    }

    if (options.deep) {
      if (isPlainObject(newValue)) {
        newValue = map(newValue, callback, options);
      } else if (Array.isArray(newValue)) {
        newValue = newValue.map(function (val) {
          return isPlainObject(val) ? map(val, callback, options) : val;
        });
      }
    }

    memo[newKey] = newValue;

    return memo;
  }, {});
}

export default map;
//# sourceMappingURL=map.js.map
