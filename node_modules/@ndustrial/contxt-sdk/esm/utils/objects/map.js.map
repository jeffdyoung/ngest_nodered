{"version":3,"sources":["utils/objects/map.js"],"names":["isPlainObject","map","input","callback","userOptions","options","deep","Object","keys","reduce","memo","key","value","result","newValue","newKey","Array","isArray","val"],"mappings":";;;;AAAA,OAAOA,aAAP,MAA0B,sBAA1B;;AAEA;;;;;;;;;;;;;;AAcA,SAASC,GAAT,CAAaC,KAAb,EAAoBC,QAApB,EAA8BC,WAA9B,EAA2C;AACzC,MAAMC;AACJC,UAAM;AADF,KAEDF,WAFC,CAAN;;AAKA,SAAOG,OAAOC,IAAP,CAAYN,KAAZ,EAAmBO,MAAnB,CAA0B,UAACC,IAAD,EAAOC,GAAP,EAAe;AAC9C,QAAMC,QAAQV,MAAMS,GAAN,CAAd;AACA,QAAME,SAASV,SAASS,KAAT,EAAgBD,GAAhB,EAAqBT,KAArB,CAAf;;AAF8C,iCAGrBW,MAHqB;AAAA,QAGzCC,QAHyC;AAAA,QAG/BC,MAH+B;;AAK9C,QAAIA,WAAW,wBAAf,EAAyC;AACvC,aAAOL,IAAP;AACD;;AAED,QAAIL,QAAQC,IAAZ,EAAkB;AAChB,UAAIN,cAAcc,QAAd,CAAJ,EAA6B;AAC3BA,mBAAWb,IAAIa,QAAJ,EAAcX,QAAd,EAAwBE,OAAxB,CAAX;AACD,OAFD,MAEO,IAAIW,MAAMC,OAAN,CAAcH,QAAd,CAAJ,EAA6B;AAClCA,mBAAWA,SAASb,GAAT,CACT,UAACiB,GAAD;AAAA,iBAAUlB,cAAckB,GAAd,IAAqBjB,IAAIiB,GAAJ,EAASf,QAAT,EAAmBE,OAAnB,CAArB,GAAmDa,GAA7D;AAAA,SADS,CAAX;AAGD;AACF;;AAEDR,SAAKK,MAAL,IAAeD,QAAf;;AAEA,WAAOJ,IAAP;AACD,GAtBM,EAsBJ,EAtBI,CAAP;AAuBD;;AAED,eAAeT,GAAf","file":"map.js","sourcesContent":["import isPlainObject from 'lodash.isplainobject';\n\n/*\n * Maps over an object (which can include nested objects and arrays).\n *\n * @param {Object} input The object to map over\n * @param {Function} callback The function invoked per iteration\n * @param {Object} [userOptions]\n * @param {Boolean} [userOptions.deep = false] Boolean indicating if only the first\n *   level should be mapped or if it should recursively map over nested\n *   objects/arrays\n *\n * @returns {Object}\n *\n * @private\n */\nfunction map(input, callback, userOptions) {\n  const options = {\n    deep: false,\n    ...userOptions\n  };\n\n  return Object.keys(input).reduce((memo, key) => {\n    const value = input[key];\n    const result = callback(value, key, input);\n    let [newValue, newKey] = result;\n\n    if (newKey === '__MARKED_FOR_REMOVAL__') {\n      return memo;\n    }\n\n    if (options.deep) {\n      if (isPlainObject(newValue)) {\n        newValue = map(newValue, callback, options);\n      } else if (Array.isArray(newValue)) {\n        newValue = newValue.map(\n          (val) => (isPlainObject(val) ? map(val, callback, options) : val)\n        );\n      }\n    }\n\n    memo[newKey] = newValue;\n\n    return memo;\n  }, {});\n}\n\nexport default map;\n"]}