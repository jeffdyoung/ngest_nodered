{"version":3,"sources":["events/index.js"],"names":["has","isPlainObject","formatEventUpdateToServer","toCamelCase","toSnakeCase","formatPaginatedDataFromServer","Events","sdk","request","baseUrl","config","audiences","events","host","_baseUrl","_request","_sdk","event","requiredFields","i","length","field","Promise","reject","Error","post","then","response","eventId","delete","get","clientId","paginationOptions","params","eventTypeId","eventFilters","userId","userEventSubscriptionId","update","formattedUpdate","put","eventType"],"mappings":"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","file":"index.js","sourcesContent":["import has from 'lodash.has';\nimport isPlainObject from 'lodash.isplainobject';\nimport { formatEventUpdateToServer } from '../utils/events';\nimport { toCamelCase, toSnakeCase } from '../utils/objects';\nimport { formatPaginatedDataFromServer } from '../utils/pagination';\n\n/**\n * @typedef {Object} Event\n * @property {boolean} allowOthersToTrigger Whether or not to allow non-owners to trigger the Event\n * @property {string} createdAt ISO 8601 Extended Format date/time string\n * @property {string} [deletedAt] ISO 8601 Extended Format date/time string\n * @property {Object} [eventType]\n * @property {string} [eventType.clientId] The ID of the client to which the event type belongs\n * @property {string} [eventType.createdAt] ISO 8601 Extended Format date/time string\n * @property {string} [eventType.description]\n * @property {string} [eventType.id] UUID formatted ID\n * @property {boolean} [eventType.isRealtimeEnabled]\n * @property {number} [eventType.level]\n * @property {string} [eventType.name]\n * @property {string} [eventType.slug]\n * @property {string} [eventType.updatedAt] ISO 8601 Extended Format date/time string\n * @property {string} [eventTypeId] UUID corresponding with an event type\n * @property {number} [facilityId] The facility associated with the event\n * @property {string} id UUID formatted ID\n * @property {boolean} [isPublic]\n * @property {string} name\n * @property {string} [organizationId] UUID of the organization to which the event belongs\n * @property {Object} [owner]\n * @property {string} [owner.createdAt]  ISO 8601 Extended Format date/time string\n * @property {string} [owner.email]\n * @property {string} [owner.firstName]\n * @property {string} [owner.id]\n * @property {boolean} [owner.isMachineUser]\n * @property {string} [owner.lastName]\n * @property {string} [owner.updatedAt]  ISO 8601 Extended Format date/time string\n * @property {string} [ownerId] The ID of the user who owns the event\n * @property {number} [topicArn] The Amazon Resource Name (ARN) associated with the event\n * @property {string} updatedAt ISO 8601 Extended Format date/time string\n */\n\n/**\n * @typedef {Object} EventsFromServer\n * @property {Object} _metadata Metadata about the pagination settings\n * @property {number} _metadata.offset Offset of records in subsequent queries\n * @property {number} _metadata.totalRecords Total number of asset types found\n * @property {Event[]} records\n */\n\n/**\n * @typedef {Object} EventType\n * @property {string} clientId UUID corresponding with the client\n * @property {string} createdAt ISO 8601 Extended Format date/time string\n * @property {string} description\n * @property {string} id UUID\n * @property {boolean} isOngoingEvent Flag for if the event is ongoing/updated frequently\n * @property {boolean} isRealtimeEnabled Flag for if the event is real time\n * @property {number} level Priority level associated with event type\n * @property {string} name\n * @property {string} slug Unique per clientId to identify the event type\n * @property {string} updatedAt ISO 8601 Extended Format date/time string\n */\n\n/**\n * @typedef {Object} EventTypesFromServer\n * @property {Object} _metadata Metadata about the pagination settings\n * @property {number} _metadata.offset Offset of records in subsequent queries\n * @property {number} _metadata.totalRecords Total number of asset types found\n * @property {EventType[]} records\n */\n\n/**\n * @typedef {Object} UserEventSubscription\n * @property {string} eventId\n * @property {string} createdAt ISO 8601 Extended Format date/time string\n * @property {string} id\n * @property {string} userId\n * @property {string} updatedAt ISO 8601 Extended Format date/time string\n */\n\n/**\n * Module that provides access to, and the manipulation\n * of, information about different events\n *\n * @typicalname contxtSdk.events\n */\nclass Events {\n  /**\n   * @param {Object} sdk An instance of the SDK so the module can communicate with other modules\n   * @param {Object} request An instance of the request module tied to this module's audience.\n   */\n  constructor(sdk, request) {\n    const baseUrl = `${sdk.config.audiences.events.host}/v1`;\n\n    this._baseUrl = baseUrl;\n    this._request = request;\n    this._sdk = sdk;\n  }\n\n  /**\n   * Creates a new event\n   *\n   * API Endpoint: '/events'\n   * Method: POST\n   *\n   * @param {Object} event\n   * @param {boolean} [event.allowOthersToTrigger]\n   * @param {string} event.eventTypeId UUID corresponding with an event type\n   * @param {number} [event.facilityId]\n   * @param {boolean} [event.isPublic]\n   * @param {string} event.name\n   * @param {string} event.organizationId UUID corresponding with an organization\n   *\n   * @returns {Promise}\n   * @fulfill {Event} Information about the new event\n   * @reject {Error}\n   *\n   * @example\n   * contxtSdk.events\n   *   .create({\n   *     allowOthersToTrigger: false,\n   *     eventTypeId: 'd47e5699-cc17-4631-a2c5-6cefceb7863d',\n   *     isPublic: false,\n   *     name: 'A Major Event',\n   *     organizationId: '28cc036c-d87f-4f06-bd30-1e78c2701064'\n   *   })\n   *   .then((event) => console.log(event))\n   *   .catch((err) => console.log(err));\n   */\n  create(event = {}) {\n    const requiredFields = ['eventTypeId', 'name', 'organizationId'];\n\n    for (let i = 0; i < requiredFields.length; i++) {\n      const field = requiredFields[i];\n\n      if (!event[field]) {\n        return Promise.reject(\n          new Error(`A ${field} is required to create a new event.`)\n        );\n      }\n    }\n\n    return this._request\n      .post(`${this._baseUrl}/events`, toSnakeCase(event))\n      .then((response) => toCamelCase(response));\n  }\n\n  /**\n   * Deletes an event\n   *\n   * API Endpoint: '/events/:eventId'\n   * Method: DELETE\n   *\n   * @param {string} eventId The ID of the Event\n   *\n   * @returns {Promise}\n   * @fulfill {undefined}\n   * @reject {Error}\n   *\n   * @example\n   * contxtSdk.events.delete('875afddd-091c-4385-bc21-0edf38804d27');\n   */\n  delete(eventId) {\n    if (!eventId) {\n      return Promise.reject(\n        new Error('An event ID is required for deleting an event')\n      );\n    }\n\n    return this._request.delete(`${this._baseUrl}/events/${eventId}`);\n  }\n\n  /**\n   * Gets information about an event\n   *\n   * API Endpoint: '/events/:eventId'\n   * Method: GET\n   *\n   * @param {string} eventId The ID of the event\n   *\n   * @returns {Promise}\n   * @fulfill {Event} Information about an event\n   * @reject {Error}\n   *\n   * @example\n   * contxtSdk.events\n   *   .get('875afddd-091c-4385-bc21-0edf38804d27')\n   *   .then((event) => console.log(event))\n   *   .catch((err) => console.log(err));\n   */\n  get(eventId) {\n    if (!eventId) {\n      return Promise.reject(\n        new Error(\n          'An event ID is required for getting information about an event'\n        )\n      );\n    }\n\n    return this._request\n      .get(`${this._baseUrl}/events/${eventId}`)\n      .then((event) => toCamelCase(event));\n  }\n\n  /**\n   * Gets all event types for a client\n   *\n   * API Endpoint: '/clients/:clientId/types'\n   * Method: GET\n   *\n   * @param {string} clientId The ID of the client\n   * @param {PaginationOptions} [paginationOptions]\n   *\n   * @returns {Promise}\n   * @fulfill {EventTypesFromServer} Event types from the server\n   * @reject {Error}\n   *\n   * @example\n   * contxtSdk.events\n   *   .getEventTypesByClientId('CW4B1Ih6M1nNwwxk0XOKI21MVH04pGUL')\n   *   .then((events) => console.log(events))\n   *   .catch((err) => console.log(err));\n   */\n  getEventTypesByClientId(clientId, paginationOptions) {\n    if (!clientId) {\n      return Promise.reject(\n        new Error('A client ID is required for getting types')\n      );\n    }\n\n    return this._request\n      .get(`${this._baseUrl}/clients/${clientId}/types`, {\n        params: toSnakeCase(paginationOptions)\n      })\n      .then((response) => formatPaginatedDataFromServer(response));\n  }\n\n  /**\n   * Gets all events by type\n   *\n   * API Endpoint: '/types/:typeId/events'\n   * Method: GET\n   *\n   * @param {string} eventTypeId The ID of the type\n   * @param {number} [eventsFilters.facilityId] ID of facility to restrict event types to\n   * @param {string[]} [eventsFilters.include] List of additional information to be included in the results. Possible options are: 'triggered.latest'\n   * @param {number} [eventsFilters.limit] Maximum number of records to return per query\n   * @param {number} [eventsFilters.offset] How many records from the first record to start the query\n   * @param {boolean} [latest = false] A boolean to determine if we only want to receive the most recent\n   *\n   * @returns {Promise}\n   * @fulfill {EventsFromServer} Event from server\n   * @reject {Error}\n   *\n   * @example\n   * contxtSdk.events\n   *   .getEventsByTypeId(\n   *      '3e9b572b-6b39-4dd5-a9e5-075095eb0867',\n   *      {\n   *        limit: 10,\n   *        offset: 0,\n   *        include: ['triggered.latest']\n   *      }\n   *    )\n   *   .then((events) => console.log(events))\n   *   .catch((err) => console.log(err));\n   */\n  getEventsByTypeId(eventTypeId, eventFilters = {}) {\n    if (!eventTypeId) {\n      return Promise.reject(\n        new Error('A type ID is required for getting events')\n      );\n    }\n\n    return this._request\n      .get(`${this._baseUrl}/types/${eventTypeId}/events`, {\n        params: toSnakeCase(eventFilters)\n      })\n      .then((events) => formatPaginatedDataFromServer(events));\n  }\n\n  /**\n   * Subscribes an user to an event\n   *\n   * API Endpoint: '/users/:userId/events/:event_id'\n   * Method: POST\n   *\n   * @param {string} userId The ID of the user\n   * @param {string} eventId The ID of the event\n   *\n   * @returns {Promise}\n   * @fulfill {UserEventSubscription} The newly created user event\n   * @reject {Error}\n   *\n   * @example\n   * contxtSdk.events\n   *   .subscribeUser('auth0|saklafjheuaiweh', '007ca9ee-ece7-4931-9d11-9b4fd97d4d58')\n   *   .then((userEvent) => console.log(userEvent))\n   *   .catch((err) => console.log(err));\n   */\n  subscribeUser(userId, eventId) {\n    if (!userId) {\n      return Promise.reject(\n        new Error('A user ID is required for subscribing a user to an event')\n      );\n    }\n\n    if (!eventId) {\n      return Promise.reject(\n        new Error('An event ID is required for subscribing a user to an event')\n      );\n    }\n\n    return this._request\n      .post(`${this._baseUrl}/users/${userId}/events/${eventId}`)\n      .then((response) => toCamelCase(response));\n  }\n\n  /**\n   * Removes an event subscription from a user\n   *\n   * API Endpoint: '/users/:userId/subscriptions/:user_event_subscription_id'\n   * Method: DELETE\n   *\n   * @param {string} userId The ID of the user\n   * @param {string} userEventSubscriptionId The ID of the user event subscription\n   *\n   * @returns {Promise}\n   * @fulfill {undefined}\n   * @reject {Error}\n   *\n   * @example\n   * contxtSdk.events\n   *   .unsubscribeUser('auth0|saklafjheuaiweh', '007ca9ee-ece7-4931-9d11-9b4fd97d4d58')\n   *   .catch((err) => console.log(err));\n   */\n  unsubscribeUser(userId, userEventSubscriptionId) {\n    if (!userId) {\n      return Promise.reject(\n        new Error('A user ID is required to unsubscribe a user from an event')\n      );\n    }\n\n    if (!userEventSubscriptionId) {\n      return Promise.reject(\n        new Error(\n          'A user event subscription ID is required for unsubscribing a user from an event'\n        )\n      );\n    }\n\n    return this._request.delete(\n      `${\n        this._baseUrl\n      }/users/${userId}/subscriptions/${userEventSubscriptionId}`\n    );\n  }\n\n  /**\n   * Updates an event\n   *\n   * API Endpoint: '/events/:eventId'\n   * Method: PUT\n   *\n   * @param {number} eventId The ID of the event to update\n   * @param {Object} update An object containing the updated data for the event\n   * @param {number} [update.facilityId]\n   * @param {boolean} [update.isPublic]\n   * @param {string} [update.name]\n   *\n   * @returns {Promise}\n   * @fulfill {undefined}\n   * @reject {Error}\n   *\n   * @example\n   * contxtSdk.events.update('875afddd-091c-4385-bc21-0edf38804d27', {\n   *   name: 'Sgt. Pepper's Lonely Hearts Club Band Event'\n   * });\n   */\n  update(eventId, update) {\n    if (!eventId) {\n      return Promise.reject(\n        new Error('An event ID is required to update an event.')\n      );\n    }\n\n    if (!update) {\n      return Promise.reject(\n        new Error('An update is required to update an event.')\n      );\n    }\n\n    if (!isPlainObject(update)) {\n      return Promise.reject(\n        new Error(\n          'The event update must be a well-formed object with the data you wish to update.'\n        )\n      );\n    }\n\n    const formattedUpdate = formatEventUpdateToServer(update);\n\n    return this._request.put(\n      `${this._baseUrl}/events/${eventId}`,\n      formattedUpdate\n    );\n  }\n\n  /**\n   * Creates a new event type\n   *\n   * API Endpoint: '/types'\n   * Method: POST\n   *\n   * @param {Object} eventType\n   * @param {string} eventType.name\n   * @param {string} eventType.description\n   * @param {number} [eventType.level] Priority level associated with event type\n   * @param {string} eventType.clientId UUID corresponding with the client\n   * @param {string} eventType.slug Unique per clientId to identify the event type\n   * @param {boolean} eventType.isRealtimeEnabled Flag for if the event is real time\n   * @param {boolean} eventType.isOngoingEvent Flag for if the event is ongoing/updated frequently\n   *\n   * @returns {Promise}\n   * @fulfill {EventType} Information about the new event type\n   * @reject {Error}\n   *\n   * @example\n   * contxtSdk.events\n   *   .createEventType({\n   *     name: 'Example name',\n   *     description: 'Example description',\n   *     level: 2,\n   *     clientId: 'd47e5699-cc17-4631-a2c5-6cefceb7863d',\n   *     slug: 'example_slug',\n   *     isRealtimeEnabled: false,\n   *     isOngoingEvent: false\n   *   })\n   *   .then((eventType) => console.log(eventType))\n   *   .catch((err) => console.log(err));\n   */\n  createEventType(eventType = {}) {\n    const requiredFields = [\n      'name',\n      'description',\n      'clientId',\n      'slug',\n      'isRealtimeEnabled',\n      'isOngoingEvent'\n    ];\n\n    for (let i = 0; i < requiredFields.length; i++) {\n      const field = requiredFields[i];\n\n      if (!has(eventType, field)) {\n        return Promise.reject(\n          new Error(`A ${field} is required to create a new event type.`)\n        );\n      }\n    }\n\n    return this._request\n      .post(`${this._baseUrl}/types`, toSnakeCase(eventType))\n      .then((response) => toCamelCase(response));\n  }\n}\n\nexport default Events;\n"]}