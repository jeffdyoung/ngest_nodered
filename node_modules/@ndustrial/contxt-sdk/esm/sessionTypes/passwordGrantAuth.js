var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import auth0 from 'auth0-js';
import axios from 'axios';

/**
 * A SessionType that allows the user to authenticate with Auth0 and
 * then gain a valid JWT from the Contxt Auth service. This method
 * utitlizes the password grant type authorization with Auth0. This
 * SessionType will expect a username and a password to be passed into
 * the `logIn` function from the user to authenticate.
 *
 * @type SessionType
 *
 * @typicalname contxtSdk.auth
 *
 * @example
 * const ContxtSdk = require('@ndustrial/contxt-sdk');
 *
 * const contxtService = new ContxtSdk({
 *   config: {
 *     auth: {
 *       clientId: '<client id>'
 *     }
 *   },
 *   sessionType: 'passwordGrantAuth'
 * });
 */

var PasswordGrantAuth = function () {
  /**
   * @param {Object} sdk An instance of the SDK so the module can communicate with other modules
   * @param {Object} sdk.audiences
   * @param {Object} sdk.audiences.contxtAuth
   * @param {string} sdk.audiences.contxtAuth.clientId The Auth0 client id of the
   *   Contxt Auth environment
   * @param {string} sdk.audiences.contxtAuth.host
   * @param {Object} sdk.config
   * @param {Object} sdk.config.auth
   * @param {string} sdk.config.auth.clientId The Auth0 client id of the application
   */
  function PasswordGrantAuth(sdk) {
    _classCallCheck(this, PasswordGrantAuth);

    this._sdk = sdk;
    this._sessionInfo = {};

    this._auth0 = new auth0.Authentication({
      domain: 'ndustrial.auth0.com',
      clientID: this._sdk.config.auth.clientId
    });
  }

  /**
   * Gets the current API token (used to communicate with other Contxt APIs)
   *
   * @returns {Promise}
   * @fulfills {string} apiToken
   * @rejects {Error}
   */


  _createClass(PasswordGrantAuth, [{
    key: 'getCurrentApiToken',
    value: function getCurrentApiToken() {
      var _this = this;

      return new Promise(function (resolve, reject) {
        if (!_this._sessionInfo.accessToken) {
          return reject(new Error('No api token found.'));
        }

        return resolve(_this._sessionInfo.accessToken);
      });
    }

    /**
     * Tells caller if the current user is authenticated
     *
     * @returns {boolean}
     */

  }, {
    key: 'isAuthenticated',
    value: function isAuthenticated() {
      var hasToken = !!(this._sessionInfo && this._sessionInfo.accessToken);

      return hasToken;
    }

    /**
     * Logs the user in using Auth0 using a username a password
     *
     * @param {string} username The username of the user to authenticate
     * @param {string} password The password of the user to authenticate
     *
     * @returns {Promise}
     * @fulfills {string}
     * @rejects {Error}
     */

  }, {
    key: 'logIn',
    value: function logIn(username, password) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        var audience = _this2._sdk.config.audiences.contxtAuth.clientId;

        _this2._auth0.loginWithDefaultDirectory({ password: password, username: username, audience: audience }, function (err, response) {
          if (err) {
            var errorMessage = err && err.description || 'Authentication failed.';

            return reject(new Error(errorMessage));
          }

          return resolve(response.accessToken);
        });
      }).then(function (accessToken) {
        return _this2._getApiToken(accessToken);
      });
    }

    /**
     * Logs the user out by removing any stored session info.
     *
     * @returns {Promise}
     * @fulfills {string}
     */

  }, {
    key: 'logOut',
    value: function logOut() {
      var _this3 = this;

      return new Promise(function (resolve) {
        _this3._sessionInfo = {};

        return resolve('Logout successful - session info cleared.');
      });
    }

    /**
     * Requests an access token from Contxt Auth with the correct audiences.
     *
     * @param {string} accessToken
     *
     * @returns {Promise}
     * @fulfill {string} accessToken
     * @rejects {Error}
     *
     * @private
     */

  }, {
    key: '_getApiToken',
    value: function _getApiToken(accessToken) {
      var _this4 = this;

      return axios.post(this._sdk.config.audiences.contxtAuth.host + '/v1/token', {
        audiences: Object.keys(this._sdk.config.audiences).map(function (audienceName) {
          return _this4._sdk.config.audiences[audienceName].clientId;
        }).filter(function (clientId) {
          return clientId && clientId !== _this4._sdk.config.audiences.contxtAuth.clientId;
        }),
        nonce: 'nonce'
      }, {
        headers: { Authorization: 'Bearer ' + accessToken }
      }).then(function (response) {
        var data = response.data;


        _this4._saveSession({
          accessToken: data.access_token
        });

        return data.access_token;
      });
    }

    /**
     * Saves the session info (i.e. the Contxt access token) for future use
     *
     * @param {Object} sessionInfo
     * @param {string} sessionInfo.accessToken
     *
     * @private
     */

  }, {
    key: '_saveSession',
    value: function _saveSession(sessionInfo) {
      this._sessionInfo = sessionInfo;
    }
  }]);

  return PasswordGrantAuth;
}();

export var TYPE = 'passwordGrantAuth';
export default PasswordGrantAuth;
//# sourceMappingURL=passwordGrantAuth.js.map
