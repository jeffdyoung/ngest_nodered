var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import axios from 'axios';

/**
 * @typedef {Object} MachineAuthSessionInfo
 * @property {string} apiToken
 * @property {number} expiresAt
 */

/**
 * A SessionType that allows machine to machine communication between Node.js servers. This would
 * only be used in Node.js applications. This SessionType requires a client id and a client secret,
 * which are obtained from Auth0.
 *
 * @type SessionType
 *
 * @typicalname contxtSdk.auth
 *
 * @example
 * const ContxtSdk = require('@ndustrial/contxt-sdk');
 *
 * const contxtSdk = new ContxtSDK({
 *   config: {
 *     auth: {
 *       clientId: '<client id>',
 *       clientSecret: '<client secret>'
 *     }
 *   },
 *   sessionType: 'machineAuth'
 * });
 */

var MachineAuth = function () {
  /**
   * @param {Object} sdk An instance of the SDK so the module can communicate with other modules
   */
  function MachineAuth(sdk) {
    _classCallCheck(this, MachineAuth);

    this._sdk = sdk;
    this._sessionInfo = {};
    this._tokenPromises = {};

    if (!this._sdk.config.auth.clientId) {
      throw new Error('clientId is required for the MachineAuth config');
    }

    if (!this._sdk.config.auth.clientSecret) {
      throw new Error('clientSecret is required for the MachineAuth config');
    }
  }

  /**
   * Removes an audience's API token from the in-memory token storage
   *
   * @param audienceName
   *
   * @returns {Promise}
   */


  _createClass(MachineAuth, [{
    key: 'clearCurrentApiToken',
    value: function clearCurrentApiToken(audienceName) {
      var _this = this;

      var promise = this._tokenPromises[audienceName] || Promise.resolve();

      return promise.then(function () {
        delete _this._sessionInfo[audienceName];
      });
    }

    /**
     * Gets the current API token (used to communicate with other Contxt APIs). Will get and store a
     * token or use a previously acquired and stored token.
     *
     * @param {string} audienceName The audience you wish to get an API for
     *
     * @returns {Promise}
     * @fulfills {string} apiToken
     */

  }, {
    key: 'getCurrentApiToken',
    value: function getCurrentApiToken(audienceName) {
      if (this.isAuthenticated(audienceName)) {
        return Promise.resolve(this._sessionInfo[audienceName].apiToken);
      }

      return this._getNewSessionInfo(audienceName).then(function (sessionInfo) {
        return sessionInfo.apiToken;
      });
    }

    /**
     * Tells caller if the app is authenticated with a particular service.
     *
     * @param audienceName
     *
     * @returns {boolean}
     */

  }, {
    key: 'isAuthenticated',
    value: function isAuthenticated(audienceName) {
      if (!(this._sessionInfo && this._sessionInfo[audienceName])) {
        return false;
      }

      var _sessionInfo$audience = this._sessionInfo[audienceName],
          apiToken = _sessionInfo$audience.apiToken,
          expiresAt = _sessionInfo$audience.expiresAt;

      var tokenExpiresAtBufferMs = this._sdk.config.auth.tokenExpiresAtBufferMs || 0;
      var bufferedExpiresAt = expiresAt - tokenExpiresAtBufferMs;

      return !!(apiToken && bufferedExpiresAt > Date.now());
    }

    /**
     * Requests an access token from Contxt Auth for the correct audience
     *
     * @param audienceName
     *
     * @returns {Promise}
     * @fulfill {MachineAuthSessionInfo}
     *
     * @private
     */

  }, {
    key: '_getNewSessionInfo',
    value: function _getNewSessionInfo(audienceName) {
      var _this2 = this;

      var audience = this._sdk.config.audiences[audienceName];

      if (!(audience && audience.clientId)) {
        return Promise.reject(new Error('No valid audience found'));
      }

      if (!this._tokenPromises[audienceName]) {
        this._tokenPromises[audienceName] = axios.post(this._sdk.config.audiences.contxtAuth.host + '/v1/oauth/token', {
          audience: audience.clientId,
          client_id: this._sdk.config.auth.clientId,
          client_secret: this._sdk.config.auth.clientSecret,
          grant_type: 'client_credentials'
        }).then(function (_ref) {
          var data = _ref.data;

          return {
            apiToken: data.access_token,
            expiresAt: Date.now() + data.expires_in * 1000
          };
        }).then(function (sessionInfo) {
          _this2._saveSession(audienceName, sessionInfo);
          _this2._tokenPromises[audienceName] = null;

          return sessionInfo;
        }).catch(function (err) {
          if (!(err.response && err.response.status)) {
            throw new Error('There was a problem getting a token from the ContxtAuth server. Please check your configuration settings.');
          }

          throw err;
        });
      }

      return this._tokenPromises[audienceName];
    }

    /**
     * Saves a session in the auth instance for future use
     *
     * @param {string} audienceName
     * @param {Object} sessionInfo
     * @param {string} sessionInfo.apiToken
     * @param {number} sessionInfo.expiresAt
     *
     * @private
     */

  }, {
    key: '_saveSession',
    value: function _saveSession(audienceName, sessionInfo) {
      this._sessionInfo = _extends({}, this._sessionInfo, _defineProperty({}, audienceName, sessionInfo));
    }
  }]);

  return MachineAuth;
}();

export var TYPE = 'machineAuth';
export default MachineAuth;
//# sourceMappingURL=machineAuth.js.map
