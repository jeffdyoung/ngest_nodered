{"version":3,"sources":["bus/webSocketConnection.js"],"names":["uuid","once","WebSocketConnection","webSocket","organizationId","_onError","error","_messageHandlers","console","log","_onMessage","message","messageData","JSON","parse","data","err","Error","id","_organizationId","_webSocket","onerror","onmessage","token","Promise","reject","_isConnected","_registerSingleMessageHandler","close","serviceClientId","channel","service_id","group","handler","errorHandler","params","then","result","subscription","subscriptionMessage","resolve","ack","_acknowledge","body","res","throwable","acknowledgedMessageId","message_id","method","messageId","send","stringify","jsonrpc","readyState","OPEN"],"mappings":"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","file":"webSocketConnection.js","sourcesContent":["import uuid from 'uuid/v4';\nimport once from 'lodash.once';\n\n/**\n * The WebSocket Error Event\n *\n * @typedef {Object} WebSocketError\n * @property {string} type The event type\n */\n\n/**\n * The WebSocket Message Event\n *\n * @typedef {Object} WebSocketMessage\n * @property {Object} data The data sent by the message emitter\n * @property {string} origin A USVString representing the origin of the message emitter\n * @property {string} lastEventId A DOMString representing a unique ID for the event\n * @property {Object} source A MessageEventSource (which can be a WindowProxy, MessagePort, or ServiceWorker object) representing the message emitter\n * @property {Array} ports  MessagePort objects representing the ports associated with the channel the message is being sent through (where appropriate, e.g. in channel messaging or when sending a message to a shared worker)\n */\n\n/**\n * Module that wraps the websocket connection to the message bus to provide the\n * developer with a specific set of functionality. This is for Node\n * environments. Documentation for browser environments is found under\n * `BrowserWebSocketConnection`.\n */\nclass WebSocketConnection {\n  /**\n   * @param {WebSocket} webSocket A WebSocket connection to the message bus\n   * @param {string} organizationId UUID corresponding with an organization\n   */\n  constructor(webSocket, organizationId) {\n    this._messageHandlers = {};\n    this._organizationId = organizationId;\n    this._webSocket = webSocket;\n\n    if (this._webSocket) {\n      this._webSocket.onerror = this._onError;\n      this._webSocket.onmessage = this._onMessage;\n    }\n  }\n\n  /**\n   * Sends a message to the message bus to authorize a channel\n   *\n   * @param {string} token JSON Web Signature containing the channel and actions needed for authorization\n   *\n   * @returns {Promise}\n   * @fulfill\n   * @reject {error} The error event from the WebSocket or the error message from the message bus\n   *\n   * @example\n   *   contxtSdk.bus.connect('4f0e51c6-728b-4892-9863-6d002e61204d')\n   *     .then((webSocket) => {\n   *       webSocket.authorize(token).then(() => {\n   *         console.log(\"authorization successful\")\n   *       })\n   *       .catch((authError) => {\n   *         console.log(authError)\n   *       });\n   *     })\n   * });\n   */\n  authorize(token) {\n    if (!token) {\n      return Promise.reject(new Error('A token is required for authorization'));\n    }\n\n    if (!this._isConnected()) {\n      return Promise.reject(new Error('WebSocket connection not open'));\n    }\n\n    return this._registerSingleMessageHandler('Authorize', { token });\n  }\n\n  /**\n   * Closes the websocket connection\n   *\n   * @example\n   * contxtSdk.bus.connect('4f0e51c6-728b-4892-9863-6d002e61204d')\n   *   .then((webSocket) => {\n   *     webSocket.close()\n   *   })\n   *   .catch((errorEvent) => {\n   *     console.log(errorEvent);\n   *   });\n   */\n  close() {\n    this._webSocket.close();\n  }\n\n  /**\n   * Handles WebSocket errors.\n   * The `ws` library also closes the socket when an error occurs.\n   * Since the socket connection closes, the jsonRpcId and message handlers are cleared\n   *\n   * @param {WebSocketError} error The error event thrown\n   *\n   * @private\n   */\n  _onError = (error) => {\n    this._messageHandlers = {};\n\n    console.log('Message Bus WebSocket Error: ', error);\n  };\n\n  /**\n   * Handles messages sent from the Message Bus WebSocket connection.\n   *\n   * @param {WebSocketMessage} message The message event recieved over the WebSocket connection\n   *\n   * @private\n   */\n  _onMessage = (message) => {\n    let messageData;\n\n    try {\n      messageData = JSON.parse(message.data);\n    } catch (err) {\n      throw new Error('Invalid JSON in message');\n    }\n\n    if (this._messageHandlers[messageData.id]) {\n      this._messageHandlers[messageData.id](messageData);\n    }\n  };\n\n  /**\n   * Publishes a message to a specific channel on the message bus\n   *\n   * @param {string} serviceClientId Client ID of the message bus service\n   * @param {string} channel Message bus channel the message is being sent to\n   * @param {Any} message Message being sent to the message bus. Must be valid JSON.\n   *\n   * @returns {Promise}\n   * @fulfill\n   * @reject {error} The error event from the WebSocket or the error message from the message bus\n   *\n   * @example\n   *   contxtSdk.bus.connect('4f0e51c6-728b-4892-9863-6d002e61204d')\n   *     .then((webSocket) => {\n   *       webSocket.publish('GCXd2bwE9fgvqxygrx2J7TkDJ3ef', 'feed:1', {\"example\": 1}).then(() => {\n   *         console.log(\"publish successful\")\n   *       })\n   *       .catch((error) => {\n   *         console.log(error)\n   *       });\n   *     });\n   */\n  publish(serviceClientId, channel, message) {\n    if (!serviceClientId) {\n      return Promise.reject(\n        new Error('A service client id is required for publishing')\n      );\n    }\n\n    if (!channel) {\n      return Promise.reject(new Error('A channel is required for publishing'));\n    }\n\n    if (!message) {\n      return Promise.reject(new Error('A message is required for publishing'));\n    }\n\n    if (!this._isConnected()) {\n      return Promise.reject(new Error('WebSocket connection not open'));\n    }\n\n    return this._registerSingleMessageHandler('Publish', {\n      service_id: serviceClientId,\n      channel,\n      message\n    });\n  }\n\n  /**\n   * Subscribes to a specific channel on the message bus and handles messages as they are received. When the handler is\n   * called, the message is automatically acknowledged after the message completes except whenever an Error is thrown.\n   * The user can also programmatically control when the message is acknowledged by calling `ack` at any time.\n   *\n   * @param {string} serviceClientId Client ID of the message bus service\n   * @param {string} channel Message bus channel the message is being sent to\n   * @param {string} [group] A unique identifier for the subscriber that can be shared between connections\n   * @param {function} handler A function that gets invoked with every received message\n   * @param {function} errorHandler A function that gets invoked with every error\n   *\n   * @example\n   *   contxtSdk.bus.connect('4f0e51c6-728b-4892-9863-6d002e61204d')\n   *     .then((webSocket) => {\n   *       webSocket.subscribe('GCXd2bwE9fgvqxygrx2J7TkDJ3ef', 'feed:1', 'test-sub', (message) => {\n   *         console.log('Message received: ', message);\n   *       }, (error) => {\n   *         console.log('Error received: ', error);\n   *       });\n   *     });\n   *\n   * @example\n   *   contxtSdk.bus.connect('4f0e51c6-728b-4892-9863-6d002e61204d')\n   *     .then((webSocket) => {\n   *       webSocket.subscribe('GCXd2bwE9fgvqxygrx2J7TkDJ3ef', 'feed:1', 'test-sub', (message, ack) => {\n   *         console.log('Message received: ', message);\n   *\n   *         ack();\n   *       }, (error) => {\n   *         console.log('Error received: ', error);\n   *       });\n   *     });\n   *\n   * @example\n   *   contxtSdk.bus.connect('4f0e51c6-728b-4892-9863-6d002e61204d')\n   *     .then((webSocket) => {\n   *       webSocket.subscribe('GCXd2bwE9fgvqxygrx2J7TkDJ3ef', 'feed:1', (message) => {\n   *         return db.save(message);\n   *       }, (error) => {\n   *         console.log('Error received: ', error);\n   *       });\n   *     });\n   *\n   * @example\n   *   contxtSdk.bus.connect('4f0e51c6-728b-4892-9863-6d002e61204d')\n   *     .then((webSocket) => {\n   *       webSocket.subscribe('GCXd2bwE9fgvqxygrx2J7TkDJ3ef', 'feed:1', (message, ack) => {\n   *         return db.save(message)\n   *           .then(ack)\n   *           .then(() => {\n   *             // additional processing\n   *           });\n   *       }, (error) => {\n   *         console.log('Error received: ', error);\n   *       });\n   *     });\n   */\n  subscribe(serviceClientId, channel, group, handler, errorHandler) {\n    if (typeof group === 'function') {\n      errorHandler = handler;\n      handler = group;\n      group = null;\n    }\n\n    if (!serviceClientId) {\n      return Promise.reject(\n        new Error('A service client id is required for subscribing')\n      );\n    }\n\n    if (!channel) {\n      return Promise.reject(new Error('A channel is required for subscribing'));\n    }\n\n    if (!handler) {\n      return Promise.reject(\n        new Error('A message handler is required for subscribing')\n      );\n    }\n\n    if (!errorHandler) {\n      return Promise.reject(\n        new Error('An error handler is required for subscribing')\n      );\n    }\n\n    if (!this._isConnected()) {\n      return Promise.reject(new Error('WebSocket connection not open'));\n    }\n\n    const params = {\n      service_id: serviceClientId,\n      channel\n    };\n\n    if (group) {\n      params.group = group;\n    }\n\n    return this._registerSingleMessageHandler('Subscribe', params).then(\n      (result) => {\n        this._messageHandlers[result.subscription] = (subscriptionMessage) => {\n          return new Promise((resolve, reject) => {\n            const error = subscriptionMessage.error;\n            const result = subscriptionMessage.result;\n\n            if (error) {\n              return resolve(errorHandler(error));\n            } else {\n              try {\n                const ack = once(() => {\n                  return this._acknowledge(result.id);\n                });\n\n                return resolve(\n                  Promise.resolve(handler(result.body, ack)).then((res) => {\n                    return ack().then(() => res);\n                  })\n                );\n              } catch (throwable) {\n                return reject(throwable);\n              }\n            }\n          });\n        };\n\n        return result;\n      }\n    );\n  }\n\n  /**\n   * Acknowledges a Message ID has been received and processed\n   *\n   * @returns {Promise}\n   * @param acknowledgedMessageId {string} The Message ID that has been received\n   * @fulfill\n   * @reject {error} The error event from the WebSocket or the error message from the message bus\n   *\n   * @private\n   */\n  _acknowledge(acknowledgedMessageId) {\n    if (!this._isConnected()) {\n      return Promise.reject(new Error('WebSocket connection not open'));\n    }\n\n    return this._registerSingleMessageHandler('Acknowledge', {\n      message_id: acknowledgedMessageId\n    });\n  }\n\n  /**\n   * Registers a JSON RPC message handler that expects only one response.\n   *\n   * @returns {Promise}\n   * @fulfill\n   * @reject {error} The error event from the WebSocket or the error message from the message bus\n   *\n   * @private\n   */\n  _registerSingleMessageHandler(method, params) {\n    return new Promise((resolve, reject) => {\n      const messageId = uuid();\n\n      this._messageHandlers[messageId] = (message) => {\n        const error = message.error;\n        delete this._messageHandlers[messageId];\n\n        if (error) {\n          return reject(error);\n        }\n\n        return resolve(message.result);\n      };\n\n      this._webSocket.send(\n        JSON.stringify({\n          jsonrpc: '2.0',\n          method: `MessageBus.${method}`,\n          params,\n          id: messageId\n        })\n      );\n    });\n  }\n\n  /**\n   * Checks whether the current WebSocket is connected to the Message Bus service.\n   *\n   * @returns {boolean} Whether the WebSocket is connected to the Message Bus service\n   *\n   * @private\n   */\n  _isConnected() {\n    return (\n      this._webSocket && this._webSocket.readyState === this._webSocket.OPEN\n    );\n  }\n}\n\nexport default WebSocketConnection;\n"]}